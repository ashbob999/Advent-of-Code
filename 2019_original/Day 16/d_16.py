import time

text = "59766299734185935790261115703620877190381824215209853207763194576128635631359682876612079355215350473577604721555728904226669021629637829323357312523389374096761677612847270499668370808171197765497511969240451494864028712045794776711862275853405465401181390418728996646794501739600928008413106803610665694684578514524327181348469613507611935604098625200707607292339397162640547668982092343405011530889030486280541249694798815457170337648425355693137656149891119757374882957464941514691345812606515925579852852837849497598111512841599959586200247265784368476772959711497363250758706490540128635133116613480058848821257395084976935351858829607105310340"

text = "03036732577212944063491565474664"

skip = int(text[0:7])  # the index of the needed answer
digits = [int(i) for i in text] * 10000  # input repeats 1000 times

# confirm that only the first 2 elements of the pattern will be used:
assert (len(digits) < 2 * skip - 1)

print(time.strftime("%H:%M:%S", time.localtime()))

for phase in range(100):  # do 100 fft calculations
	# print(phase)
	checksum = sum(digits[skip:])  # sum of digits from skip to end
	new_digits = \
		[0] * skip + \
		[int(str(checksum)[-1])]  # get the int value of the last char
	for n in range(skip + 2, len(digits) + 1):
		checksum -= digits[n - 2]
		new_digits += [int(str(checksum)[-1])]
	digits = new_digits  # resets digit array

print(time.strftime("%H:%M:%S", time.localtime()))

print("Part 2 - ", ''.join(str(i) for i in digits[skip:(skip + 8)]))  # gets the 8 digits after skip
# 28872305
